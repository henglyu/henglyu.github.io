{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/05/07/hello-world/"},{"title":"基于Github+Hexo的博客搭建","text":"准备工作使用Github+Hexo搭建博客，前期需要四个工具 环境 描述 GitHub 国内一款面向开发者的云端开发平台，提供代码托管，运行空间，质量控制，项目管理等功能 Git 一款免费、开源的分布式版本控制系统 Node.js 建立在Chrome上的JavaScript运行引擎 Hexo Hexo快速、简洁且高效的博客框架 1.1、安装与配置环境安装必要的配置环境，如果已经安装过，可以跳过。 Github Github 官方网站：https://github.com/ 注册一个 Github 账号。 新建一个 Repository，格式为【你的Github账户名.github.io】 Git 参考：https://blog.csdn.net/qq_41782425/article/details/85183250 安装Git Git 下载地址 ：https://git-scm.com/downloads 安装系统对应版本 Git，全部默认配置即可。 配置Git 打开 Git Bash 命令行（打开 Git Bash 快捷方式或右键选择 Git Bash Here 都可）。 配置用户名、邮箱（替换双引号内为对应名称即可）。 12git config --global user.name &quot;yourusername&quot;git config --global user.email &quot;youremail@example.com&quot; 创建 SSH Key 12cd ~/.sshssh-keygen -t rsa -C &quot;youremail@example.com&quot; 创建完成后，在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人. 登录github注册或登录账号，打开“settings”的“SSH Keys”页面，然后，点“New SSH Key”，填上任意 Title，在 Key 文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的 Key。 安装Node.js 下载地址：https://nodejs.org/en/ 下载LTS的，一直点Next，除了改安装目录外，其他按照默认的就可以。打开 Node.js command prompt 命令行窗口，输入 node -v 和 **npm -v **如果可以正常出现版本号，证明安装成功了！(要是这里出现了问题那就从头开始吧…) 安装 Hexo在 Node.js command prompt 命令行窗口输入下面命令来安装 Hexo： 123npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-clihexo -v 能够正常出现版本信息就成功了！(如果失败，就重新安装吧) 开始搭建创建博客 在任意地方创建文件夹，用于储存博客内容。如 D:\\blog。 使用hexo来初始化blog。 123cd blog/hexo inithexo s 然后会生成一个地址: http://localhost:4000 在浏览器中打开可以看到已经初始化的博客 然后就可以在 blog/source/_posts 文件夹中编辑博客了。 把 hexo 搭建的博客部署到 Github 上 回到命令行窗口，在blog目录下安装一个git部署插件： 1cnpm install --save hexo-deployer-git 打开blog文件夹，编辑 **”_config.yml” **文件(可以用文本编辑器Notepad++)拉到文件夹最底部，修改如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 'git' repo: 这里的地址就是你刚刚创建的仓库的地址，即：https://github.com/你的Github名/你的Github名.github.io.git 这种格式 branch: master 最后一步，部署到远端： 1hexo s 这里可能会跳出来窗口让你输入你的GitHub名和密码。回到你的GitHub仓库，刚刚创建的空仓库会多了很多东西。以后访问博客就可以在浏览器输入”你的Github账户名.github.io”进行访问了！！！例如：henglyu.github.io 选择一个主题 主题官网：https://hexo.io/themes/ 这里我以 ICARUS 为例， 官网中也给出了教程：Icarus快速上手 从GitHub的仓库中下载源码的压缩包并解压到你Hexo站点的主题目录中。 或者，你可以使用Git来克隆Icarus的代码仓库到themes目录下： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 接下来，在你的站点的_config.yml文件中的开启Icarus： 1hexo config theme icarus 最后，使用如下命令来启动Hexo本地测试服务器并开始创作。 1hexo server 配置主题各个参数 参考：Icarus用户指南 - 主题配置 打开 _config.icarus.yml 文件，进行主题配置 ，参考上面官网教程，这里不再赘述。 NOTE由于本人不是前端工程师，搭建博客的初衷也是想拥有自己的知识库，以便知识的沉淀。因此在此处不做过多的研究，搭建出能用的框架即可。","link":"/2022/05/07/%E5%9F%BA%E4%BA%8EGithub+Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"C语言项目编码规范(个人用)","text":"项目创建项目目录结构创建一个项目时，按照以下目录结构创建： 12345678910111213141516171819202122232425262728293031323334project [项目]|- data [存放数据的文件夹]| |- data set 1 [数据集1]| |- data set 2 [数据集2]| |- ...| |- dataDescription.md [数据集描述]|- doc [项目描述文件夹]| |- matlab code [项目预演 matlab 代码]| |- project algorithms description [项目算法描述文档]| |- project review record [项目评审记录]| |- other related files [其他项目相关文档]|- src [项目源文件]| |- main functions.c/.h [对外接口头文件和源文件]| |- module 1 functions.c/.h [模块 1 头文件和源文件]| |- module 2 functions.c/.h [模块 2 头文件和源文件]| |- ...| |- CMakeList.txt [Cmake 配置]|- test [项目测试文件]| |- integration test [集成测试]| | |- it_project.cpp | | |- CMakeList.txt | |- system test [系统测试]| | |- st_project.cpp | | |- CMakeList.txt | |- unit test [单元测试]| | |- ut_module1.cpp [模块 1 测试]| | |- ut_module2.cpp [模块 2 测试]| | |- ...| | |- CMakeList.txt|- tools [项目使用的相关工具]|- CMakeList.txt [项目 Cmake 配置]|- config.h.in [项目配置文件]|- example.cpp [项目例子程序]|- descriptions of project using [项目操作说明文档] 项目通用配置项src/CMakeList.txt >folded1234567891011121314151617181920212223242526272829# 设置应用程序名称 set(libName ${PROJECT_NAME}) # 对外公开头文件 file(GLOB lib_hxx ${CMAKE_CURRENT_SOURCE_DIR}/${libName}.h ) # 将工程目录下的子目录中所有源文件名称保存到变量中 file(GLOB_RECURSE lib_src ${CMAKE_CURRENT_SOURCE_DIR}/*.h ${CMAKE_CURRENT_SOURCE_DIR}/*.hpp ${CMAKE_CURRENT_SOURCE_DIR}/*.c ${CMAKE_CURRENT_SOURCE_DIR}/*.cc ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp ) # 将CMake设置文件添加到包含文件的搜索路径中 include_directories(${incPath}) link_directories(${linkPath}) # 编译库文件 add_library(${libName} STATIC ${lib_src}) # 安装库文件到指定路径 install(TARGETS ${libName} DESTINATION ${out_dir_lib}) # 安装库引用文件到指定路径 install(FILES ${lib_hxx} DESTINATION ${out_dir_include}) test/CMakeList.txt >folded1234567if(NOT DEFINED ENV{GTEST_HOME}) set(ENV{GTEST_HOME} &quot;C:\\\\gtest&quot;) endif() add_subdirectory(unit_test) add_subdirectory(integration_test) add_subdirectory(system_test) test/integreation_test/CMakeList.txt >folded1234567891011121314151617181920212223242526272829303132333435363738# 设置单元测试程序名称 set(appName ${PROJECT_NAME}_it) link_directories(${linkPath}) # 将第三方库（GTest）头文件添加到包含文件的搜索路径中，相当于 -Iinclude_directories( ${incPath} $ENV{GTEST_HOME}/include $ENV{GTEST_HOME}/include/gtest ${PROJECT_SOURCE_DIR}/src ${PROJECT_SOURCE_DIR}/libs/include ) # 设置第三方库（GTest）库文件链接的目录，相当于 -Llink_directories( ${linkPath} $ENV{GTEST_HOME}/lib ) # 链接第三方库（GTest），用于链接静态库，定义在 add_executable 之前 link_libraries(gtest) # 将工程目录下的子目录中所有源文件名称保存到变量中 file(GLOB_RECURSE lib_src ${CMAKE_CURRENT_SOURCE_DIR}/*.h ${CMAKE_CURRENT_SOURCE_DIR}/*.hpp ${CMAKE_CURRENT_SOURCE_DIR}/*.c ${CMAKE_CURRENT_SOURCE_DIR}/*.cc ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp ) # 编译可执行文件 add_executable(${appName} ${lib_src} ) # 标准库和自定义库指定，用于链接动态库，定义在 add_executable 之后，相当于 -ltarget_link_libraries(${appName} ${PROJECT_NAME} -Wl,--whole-archive ${dependencyLibrarys} -Wl,--no-whole-archive pthread gtest gtest_main ) CMakeList.txt >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# 设置cmake最低版本 cmake_minimum_required(VERSION 3.15) STRING(REGEX REPLACE &quot;.*/(.*)&quot; &quot;\\\\1&quot; PROJECT_NAME ${CMAKE_CURRENT_SOURCE_DIR}) # 设置工程名称 project(${PROJECT_NAME}) set(CMAKE_CXX_STANDARD 11) # 设置库版本号 (将 0.0.0.0 更改为对应版本号，每次代码提交都要变更)set(LIB_VERSION 0.0.0.0) # 数据保存开关，用于保存依赖子库的数据 #set(SAVE_DATA_MODE ON) # 设置安装路径 if(NOT DEFINED ${out_dir}) set(out_dir &quot;${PROJECT_SOURCE_DIR}/..&quot;) endif() set(CMAKE_INSTALL_PREFIX &quot;${out_dir}&quot;) # 设置库文件安装路径 set(out_dir_lib &quot;${out_dir}/lib&quot;) # 设置库文件安装路径 set(out_bin_lib &quot;${out_dir}/bin/${PROJECT_NAME}&quot;) # 设置库引用文件安装路径 set(out_dir_include &quot;${out_dir}/include&quot;) # ON(单片机模式)，OFF(文件系统模式) set(SINGLE_CHIP_MODE OFF) #设置依赖库 （自行设置）set(dependencyLibrarys libyyjson libanal_log libyyini libanal_serialize) # 编译时间 string(TIMESTAMP BUILD_TIME &quot;%Y-%m-%d %H:%M:%S&quot;) set(LIB_BUILD_TIME ${BUILD_TIME}) set(libName ${PROJECT_NAME}) # 配置一个头文件，通过它向源代码中传递一些CMake设置 configure_file( &quot;${PROJECT_SOURCE_DIR}/config.h.in&quot; &quot;${PROJECT_BINARY_DIR}/config.h&quot; ) # 输出库编译信息 message(STATUS &quot;${PROJECT_NAME} version: ${LIB_VERSION}&quot;) message(STATUS &quot;${PROJECT_NAME} build time: ${BUILD_TIME}&quot;) # 数据保存开关打开则增加宏定义 SAVE_DATA_MODEif (${SAVE_DATA_MODE} AND ${SAVE_DATA_MODE} STREQUAL &quot;ON&quot;) add_compile_definitions(SAVE_DATA_MODE=1) add_definitions(-DSAVE_DATA_MODE=1) endif () # 设置头文件路径 set(incPath ${PROJECT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/src ${out_dir_include}) # 设置链接库路径 set(linkPath ${out_dir_lib}) add_definitions(-DCUR_LIB_PATH=&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;) # 配置所依赖的静态库 foreach (l ${dependencyLibrarys}) add_library(${l} STATIC IMPORTED) set_property(TARGET ${l} PROPERTY IMPORTED_LOCATION ${linkPath}/${l}.a) endforeach () # 依次编译内部使用库 add_subdirectory(src) IF (CMAKE_SYSTEM_NAME MATCHES &quot;Windows&quot;) add_subdirectory(test) ENDIF () # 设置头文件搜索路径 include_directories( ${PROJECT_SOURCE_DIR}/src ${incPath}) # 设置库搜索路径 link_directories(${linkPath}) # 编译可执行文件 add_executable(${PROJECT_NAME}_example example.cpp) target_link_libraries(${PROJECT_NAME}_example ${PROJECT_NAME} -Wl,--whole-archive ${dependencyLibrarys} -Wl,--no-whole-archive ) # 安装例子程序到指定路径 install(TARGETS ${PROJECT_NAME}_example DESTINATION ${out_bin_lib}) # 安装库引用文件到指定路径 install(FILES example.cpp DESTINATION ${out_bin_lib}) config.h.in >folded12345678#ifndef CONFIG_H #define CONFIG_H #define LIB_VERSION &quot;@LIB_VERSION@&quot; #define LIB_NAME &quot;@libName@&quot; #define LIB_BUILD_TIME &quot;@LIB_BUILD_TIME@&quot; #endif // CONFIG_H 项目代码编写流程准备阶段 根据 项目目录结构 创建对应文件夹与文件，可以编写通用模板，以便可以直接复制从而创建新项目 在 doc 文件夹放置算法的设计思路文件与 MATLAB 预演代码（假设已经在 MATLAB 进行过实验） 确定对外接口头文件 ProjectName.h 和对应源文件 ProjectName.c（源文件此时为一系列空函数） 预先准备好测试数据与预期的结果数据，放入 data 文件夹（一般情况下应与 MATLAB 预演版本数据保持一致） 修改 example.cpp 文件，调用 ProjectName.c 的空文件，完成整个项目的框架 修改 CMakeLists.txt 文件（修改版本号，如果调用了外部库则需要添加依赖库） 调试 example.cpp 代码 ，确保在框架的正常运行 编码阶段 在 src 文件夹下编写功能代码 在 test/unit_test 文件夹下编写单元测试代码 调试 src 和 test/unit 文件夹下的代码直到测试通过 在 ProjectName.c 中调用 src 各个模块的子函数 调试 example.cpp 代码，直至输出与预期相符 编写 Readme.md 例子程序说明文档，介绍本项目的功能、参数、注意事项、函数调用流程等 测试阶段 在 test/integration_test 中编写集成测试，主要测试接口输入参数的异常处理，函数调用顺序的异常处理 在 test/system_test 中编写系统测试，主要测试异常数据导致的错误 C语言编码规范主要参考 PEP7，并做了适当调整 排版 使用 4 个空格的缩进，完全没有制表符。 任何行都不应超过 79 个字符。 任何行都不应该以空格结尾 函数定义风格：‘{’ 不需独占一行，‘}’ 需独占一行，同时与引用代码块的语句左对齐，局部变量声明后空行。123456789static intextra_ivars(PyTypeObject *type, PyTypeObject *base){ int t_size = PyType_BASICSIZE(type); int b_size = PyType_BASICSIZE(base); assert(t_size &gt;= b_size); /* type smaller than base! */ ... return 1;} 代码结构：关键字（如if、for）和后面的左括号之间有一个空格；括号内没有空格；即使 C 允许省略，任何地方都需要大括号，但不要将它们添加到您没有修改的代码中。所有新的 C 代码都需要大括号。大括号的格式应如下所示：123456if (mro != NULL) { ...}else { ...} return 语句不应该有多余的_括号_12return albatross; /* correct */return(albatross); /* incorrect */ 函数和宏调用风格：foo(a, b, c) - 左括号前无空格，括号内无空格，逗号前无空格，每个逗号后一个空格。 始终在赋值、布尔和比较运算符周围放置空格。在使用大量运算符的表达式中，在最外层（最低优先级）运算符周围添加空格。 打断长行：如果可以的话，在最外层参数列表中的逗号后打断。始终适当地缩进续行，例如：123PyErr_Format(PyExc_TypeError, &quot;cannot create '%.100s' instances&quot;, type-&gt;tp_name); 当您在二元运算符处中断一个长表达式时，该运算符位于上一行的末尾，并且括号应按所示格式化。例如：123456if (type-&gt;tp_dictoffset != 0 &amp;&amp; base-&gt;tp_dictoffset == 0 &amp;&amp; type-&gt;tp_dictoffset == b_size &amp;&amp; (size_t)t_size == b_size + sizeof(PyObject *)){ return 0; /* &quot;Forgive&quot; adding a __dict__ only */} 在函数、结构定义和函数内部的主要部分周围放置空白行。 注释位于他们描述的代码之前。 所有函数和全局变量都应声明为静态，除非它们是已发布接口的一部分 对于外部函数和变量，我们总是在“Include”目录下合适的头文件中声明，其中使用了 PyAPI_FUNC() 宏和 PyAPI_DATA() 宏，如：12PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);PyAPI_DATA(PyTypeObject) PySuper_Type; 命名单词命名 不允许使用单个字符（如 i j k）命名，作为局部循环变量除外 命名单词为全英文，不允许使用中文拼音 函数/方法名：一般采用动宾结构命名。如果是类中的方法名，可以直接使用动词结构 避免使用无意义或含义不清的动词为函数命名。如 process、handle 外部可见的标识符应加上模块名，防止编译、链接时产生冲突 用正确的反义词组命名具有互斥意义的变量或相反动作的函数 word 1 word 2 word 1 word 2 word 1 word 2 add remove begin end create destroy insert previous first last get release next decrement put get add delete lock unlock open close min max old new start stop increment decrement cut paste up down 命名风格 包/文件夹：采用小驼峰命名规则，比如 ecgBinaryClassification 文件名：下划线方式，比如 ecg_binary_classification 类/结构体/自定义类型名：大驼峰法，比如 EcgBinaryClassification 函数/方法名：采用小驼峰或下划线，这里建议采用小驼峰方式 局部变量名：采用小驼峰或下划线，这里建议采用小驼峰方式 静态变量名：采用在局部变量规则前加 s_ 的形式 全局变量名：采用在局部变量规则前加 g_ 的形式 内部符号：采用在符号前加 _ 的形式 私有符号：采用在符号前加 __ 的形式 常量：全部大写，单词与单词之间采用下划线连接 注释源程序有效注释量必须在20％以上 文件注释123456789101112131415161718192021222324252627282930/** * @file 文件名* @brief 实例功能简述 * @details 实例功能详述 * @author 作者名* @date 2022-5-13 14:47:11* @version 版本号* @copyright Copyright * @attention * &lt;ul&gt; * &lt;li&gt;注意1&lt;/li&gt; * &lt;li&gt;注意2&lt;/li&gt; * &lt;/ul&gt; * @par 修改日志 * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;日期&lt;/th&gt; * &lt;th&gt;版本&lt;/th&gt; * &lt;th&gt;作者&lt;/th&gt; * &lt;th&gt;修改内容&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本1&lt;/td&gt; * &lt;td&gt;创建者名称&lt;/td&gt; * &lt;td&gt;创建初始版本&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本2&lt;/td&gt; * &lt;td&gt;修改者名称&lt;/td&gt; * &lt;td&gt;修改内容&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; */ 函数注释 函数，原则上都需要加注释，尤其是接口函数和逻辑比较复杂的函数 函数的返回值注释要清楚、明了123456789101112131415161718/** * @name 函数名* @brief 函数功能简介 * @details 函数详细描述* * @param[in] 输入变量名 输入变量介绍* @param[out] 输出变量名 输出变量介绍* @return 返回值* * @author 作者* @date 时间* * @par 示例: * @code * 函数使用实例 * @endcode * @see 类、结构体、枚举等（超链接） */ 变量注释 变量：要求静态变量和全局变量必须加注释 命名中若使用特殊约定或缩写，必须有注释说明 其他注释 语句：有技巧性的代码语句，必须添加注释 TODO：尽量不使用 “待完善” “待明确”等模糊词，而使用相对明确的方式，如# TODO(author) 添加低通滤波功能. 函数 每个函数完成一个功能 函数的入参和出参不允许直接传递结构体对象，需改为指针 行数限制 200 行，如果某个函数有效代码超过 200 行，考虑分拆。 语句嵌套：主要是 if...else ,, while ， for 等，要求嵌套不超过 3 层， switch...case 不超过五层。 明确函数功能，精确（而不是近似）地实现函数设计 对所调用函数的错误返回码要仔细、全面地处理 编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V 操作）等手段对其加以保护 检查函数所有参数输入的有效性 检查函数所有非参数输入的有效性，如数据文件、公共变量等 防止把没有关联的语句放到一个函数中。在编程时，经常遇到在不同函数中使用相同的代码，需要把这些代码提出来，并构成一个新函数。 减少函数本身或函数间的递归调用 不能随意改变与其它模块的接口 数入参为指针或者有其他有限制的值时必须加入入参检测 语句循环 循环体内工作量最小化 避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中 在多重循环中，应将最忙的循环放在最内层 要防止差1 错误。此类错误一般是由于把 &lt;=** 误写成 **&lt;** 或 **&gt;= 误写成 &gt; 等造成的，由此引起的后果，很多情况下是很严重的 for 循环中不要使用 return 来退出双重循环，可以使用标志位判断来退出双重循环 临界资源操作临界资源包括内存、文件、句柄等 过程/函数中分配的内存，在过程/函数退出之前要释放 过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭 申请了临界资源后只有一个出口 return 来退出过程/函数，以防止忘记关闭临界资源 防止内存/数组操作越界 其他 用括号明确表达式的操作顺序，避免使用默认优先级 判断条件的执行语句必须用花括号括起来 不允许直接使用数字，需用宏定义或变量替换 关系较为紧密的代码应尽可能相邻 要使用难懂的技巧性很高的语句，除非很有必要时。且必须加注释 尽量减少没有必要的数据类型默认转换与强制转换 初始化有关变量及运行环境，防止未经初始化的变量被引用 判断性语句，把常量放在表达式的左边 if 语句尽量加上 else 分支，对没有 else 分支的语句要小心对待；switch 语句必须有 default 分支 使用变量时要注意其边界值的情况。如 C 语言中字符型变量，有效值范围为 -128 到 127 求余和除法要做除数的0值判断 用 free() 函数时需要对入参判断其是否为空指针 自定义类型 结构的功能要单一 不要设计面面俱到、非常灵活的数据结构 仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象 避免使用 BOOL 类型 变量 申请的变量必须初始化 严禁使用未经初始化的变量作为右值 使用静态变量和全局变量时，仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系 代码测试 单元测试要求至少达到语句覆盖。 单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。 清理、整理或优化后的代码要经过审查及测试。 代码版本升级要经过严格测试。 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题 仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。 尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。 仔细测试代码处理数据、变量的边界情况 不应通过“试”来解决问题，应寻找问题的根本原因。 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题 其他 去除编译中的所有警告","link":"/2022/05/13/C%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83-%E4%B8%AA%E4%BA%BA%E7%94%A8/"},{"title":"C语言-一种面向对象的编程模板","text":"使用该模板需要按照 编程规范目录形式配置项目。 demo_lib123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280/** * @file demo_lib.c * @brief 找最大值为例的编程模板* @details 找最大值为例的编程模板* @author * @date * @version * @copyright * @attention * &lt;ul&gt; * &lt;li&gt;注意1&lt;/li&gt; * &lt;li&gt;注意2&lt;/li&gt; * &lt;/ul&gt; * @par 修改日志 * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;日期&lt;/th&gt; * &lt;th&gt;版本&lt;/th&gt; * &lt;th&gt;作者&lt;/th&gt; * &lt;th&gt;修改内容&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本1&lt;/td&gt; * &lt;td&gt;创建者名称&lt;/td&gt; * &lt;td&gt;创建初始版本&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本2&lt;/td&gt; * &lt;td&gt;修改者名称&lt;/td&gt; * &lt;td&gt;修改内容&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; */ #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &quot;config.h&quot; #include &quot;demo_lib.h&quot; #ifdef LOG_TAG #undef LOG_TAG #endif #define LOG_TAG &quot;demo lib&quot; /** * @name demoLibVersion * @brief 获取库的版本号 * @details 获取库的版本号 * * @return 库的版本号 * * @author * @date * */ const char *demoLibVersion(void) { return LIB_NAME &quot; version &quot; LIB_VERSION &quot; &quot; LIB_BUILD_TIME; } /** * @name newDemoLib * @brief 库初始化 * @details 库初始化 * * @param[in] conf 配置结构体 * @return * @retval 0 成功 * @retval !0 失败 * * @author * @date * */ DemoLib *newDemoLib(const DemoLibConf *conf) { DemoLib *_this = NULL; // 入参有效性检查 if ((NULL == conf) || (NULL == conf-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return _this; } // 记录调用操作 LOGI(&quot;%s&quot;, conf-&gt;name); /************************* 申请资源 **************************/// 计算空间大小 size_t len = sizeof(DemoLib) + strnlen(conf-&gt;name, MAX_STR_LEN) + 1; if ((conf-&gt;dataPath) &amp;&amp; (0 &lt; strnlen(conf-&gt;dataPath, MAX_STR_LEN))) { len += strnlen(conf-&gt;dataPath, MAX_STR_LEN) + 1; } // 申请空间 void *p = malloc(len); if (p) { memset(p, 0, len); // 初始化 _this = (DemoLib *) p; char *name = (char *) p + sizeof(DemoLib); strncpy(name, conf-&gt;name, strnlen(conf-&gt;name, MAX_STR_LEN)); _this-&gt;name = name; _this-&gt;fs = conf-&gt;fs; /************************* 如果配置了数据路径则开启记录 **************************/ if (conf-&gt;dataPath) { if (0 &lt; strnlen(conf-&gt;dataPath, MAX_STR_LEN)) { char *dataPath = (char *) _this-&gt;name + strnlen(_this-&gt;name, MAX_STR_LEN) + 1; strncpy(dataPath, conf-&gt;dataPath, strnlen(conf-&gt;dataPath, MAX_STR_LEN)); _this-&gt;dataPath = dataPath; } else { // 路径为空字符串时，使用当前运行路径 _this-&gt;dataPath = &quot;.&quot;; } // 记录配置信息 char fileName[MAX_STR_LEN] = {0}; snprintf(fileName, sizeof(fileName), &quot;%s/demo_lib.conf&quot;, conf-&gt;dataPath); //serializeWriteData(fileName, conf, AS_DemoLibConf); // 打开实时记录输入文件 memset(fileName, 0, sizeof(fileName)); snprintf(fileName, sizeof(fileName), &quot;%s/realtimeDemoLibScan_in.csv&quot;, conf-&gt;dataPath); _this-&gt;fdIn = fopen(fileName, &quot;w&quot;); // 打开实时记录输出文件 memset(fileName, 0, sizeof(fileName)); snprintf(fileName, sizeof(fileName), &quot;%s/realtimeDemoLibScan_out.csv&quot;, conf-&gt;dataPath); _this-&gt;fdOut = fopen(fileName, &quot;w&quot;); } else { _this-&gt;dataPath = NULL; } } return _this; } /** * @name delDemoLib * @brief 库资源释放 * @details 库资源释放 * * @return * @retval 0 成功 * @retval !0 失败 * * @author zq537 * @date 2021-01-27 15:08 * */ int delDemoLib(DemoLib **_thisP) { // 入参有效性检查 if ((NULL == _thisP) || (NULL == *_thisP) || (NULL == ((DemoLib *)*_thisP)-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return -1; } DemoLib *_this = *_thisP; // 记录调用操作 //LOGI(&quot;%s&quot;, _this-&gt;name); /************************* 释放资源 **************************/ if (_this-&gt;fdIn) { fclose(_this-&gt;fdIn); } if (_this-&gt;fdOut) { fclose(_this-&gt;fdOut); } // 释放空间 free(_this); *_thisP = NULL; return 0; } static int _initDemoLib(DemoLib *_this) { memset(_this-&gt;demoLibResult, 0, sizeof(_this-&gt;demoLibResult)); _this-&gt;lastResult = 0; return 0; } /** * @name initDemoLib * @brief 库初始化 * @details 库初始化 * * @return * @retval 0 成功 * @retval !0 失败 * * @author zq537 * @date 2021-01-27 15:08 * */ int initDemoLib(DemoLib *_this) { // 入参有效性检查 if ((NULL == _this) || (NULL == _this-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return -1; } // 记录调用操作 //LOGI(&quot;%s&quot;, _this-&gt;name); return _initDemoLib(_this); } static int _realtimeDemoLibScan(DemoLib *_this, const int data) { if (_this-&gt;lastResult &lt; data) { _this-&gt;lastResult = data; } return _this-&gt;lastResult; } /** * @name demoLibScan * @brief 找数据中的最大值 * @details * * @param[in] data 数据数组 * @param[in] dataNum 数据数组长度 * @return 最大值 * * @author zq537 * @date 2021/1/27 14:55 * * @par 示例: * @code * 函数使用实例 * @endcode * @see 类、结构体、枚举等（超链接） */ int demoLibScan(DemoLib *_this, const int *data, const int dataNum) { // 入参有效性检查 if ((NULL == _this) || (NULL == _this-&gt;name) || (NULL == data) || (0 &gt;= dataNum)) { LOGE(&quot;Input parameter exception.&quot;); return -1; } //记录调用操作 //LOGI(&quot;%s&quot;, _this-&gt;name); /************************* 记录输入数据 **************************/ if (_this-&gt;dataPath) { char fileName[256] = {0}; snprintf(fileName, sizeof(fileName), &quot;%s/demoLibScan_in.csv&quot;, _this-&gt;dataPath); //serializeWriteDataArray(fileName, data, dataNum, AS_Int); } /************************* 库的实际功能代码 **************************/// todo:初始化 _this 内的所有缓存 _initDemoLib(_this); int maxData = 0; for (int i = 0; i &lt; dataNum; ++i) { maxData = _realtimeDemoLibScan(_this, data[i]); } /************************* 记录输出数据 **************************/ if (_this-&gt;dataPath) { char fileName[256] = {0}; snprintf(fileName, sizeof(fileName), &quot;%s/demoLibScan_out.csv&quot;, _this-&gt;dataPath); // serializeWriteData(fileName, &amp;maxData, AS_Int); FILE *fd = fopen(fileName, &quot;w&quot;); fprintf(fd,&quot;%d&quot;,maxData); fclose(fd); } return maxData; } int realtimeDemoLibScan(DemoLib *_this, const int data) { // 入参有效性检查 if ((NULL == _this) || (NULL == _this-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return -1; } //记录调用操作，此行非必须行。如果操作频繁导致日志太多则注释掉改行 // LOGI(&quot;%s&quot;, _this-&gt;name); /************************* 记录输入数据 **************************/ if (_this-&gt;fdIn) { fprintf(_this-&gt;fdIn, &quot;%d\\n&quot;, data); fflush(_this-&gt;fdIn); } /************************* 库的实际功能代码 **************************/ int maxData = _realtimeDemoLibScan(_this, data); /************************* 记录输出数据 **************************/ if (_this-&gt;fdOut) { fprintf(_this-&gt;fdOut, &quot;%d\\n&quot;, maxData); fflush(_this-&gt;fdOut); } return maxData; }","link":"/2022/05/13/C%E8%AF%AD%E8%A8%80-%E4%B8%80%E7%A7%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF/"},{"title":"基线修正","text":"实验目的基线漂移（0.05-1.5 Hz）与 ST 段（0.7-2.0 Hz）有频率重叠，使用常规高通滤波会导致 ST 段失真。使用较低（0.67 Hz）低通滤波时又滤不干净基线漂移，因此需要找到一种可以避免ST失真的基线漂移修正方案。 实验设备与软件设备：64位windows 10 专业版20H2，I7-9700 CPU，32GB 内存软件：Matlab2020a、ubuntu（或cygwin64）、WFDB 数据来源/划分 数据来源 法规校准用 CAL 数据 CAL20100 CAL20110 CAL20160 MIT 基线漂移数据 bw.dat Note：bw 数据共有 30 分钟， 上图只显示其中的一段 20 s 数据，在每次实验取随机一段与信号等长的数据。 Matlab 模拟数据 单正弦信号$bw_1(n)=Asin(2\\pi fn)$ 多正弦信号$bw_1(n)=Asin(2\\pi fn)+5Asin(2\\pi \\frac{f}{5}n)+10Asin(2\\pi \\frac{f}{10}n)$ 周期性门信号（宽度 100 ms / 幅度 3 mV）$square_{ecg}(n)=\\prod(n)$ 用于合规性检测 数据划分根据不同种类信号与不同种类基线漂移，本次实验共有10种组合，分别为 MIT 基线 单正弦基线 多正弦基线 CAL 20100 组合1 组合4 组合7 CAL 20110 组合2 组合5 组合8 CAL 20160 组合3 组合6 组合9 门信号 组合10 （不添加基线漂移） 实验方法、分析和难点 实验方法本次实验为初步实验，首先分析一部分目前可以利用的基线漂移滤波器，并观察这些滤波器在不同输入信号下的滤波效果。本次实验涉及到的滤波器包括： 0.67 Hz 整系数高通 FIR 滤波器 S-G 滤波器 小波滤波 EMD 滤波 VMD 滤波 分段三次样条滤波 平滑先验滤波 beads 凸优化滤波S-G 滤波器 Savitzky-Golay滤波器（通常简称为S-G滤波器）最初由Savitzky和Golay于1964年提出，发表于Analytical Chemistry 杂志。之后被⼴泛地运⽤于数据流平滑除噪，是⼀种在时域内基于局域多项式最⼩⼆乘法拟合的滤波⽅法。这种滤波器最⼤的特点在于在滤除噪声的同时可以确保信号的形状、宽度不变。 原理简介：设滤波窗口的宽度为$N=2m+1$，各测量点为$x(i), i=-m,-m+1,..,0,..,m-1,m$,采用 k-1 次多项式对窗口内的数据点进行拟合$y =a_0+a_1x+a_2x^2+…+a_{k-1}x^{k-1}$于是就有了n个这样的方程，扣成了k元线性方程组。要使方程组有解则n应大于等于k，一般选择n&gt;k，通过最小二乘法拟合确定拟合参数A。由此得到$\\begin{pmatrix} y_{-m} \\y_{-m-1}\\…\\y_{-m}\\ \\end{pmatrix} =\\begin{pmatrix}1 &amp; -m &amp; … &amp; (-m)^{k-1} \\1 &amp; -m+1 &amp; … &amp; (-m+1)^{k-1} \\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\1 &amp; m &amp; … &amp; (m)^{k-1} \\\\end{pmatrix}\\begin{pmatrix}a_0 \\a_1 &amp; \\\\vdots \\a_{k-1} \\\\end{pmatrix}+\\begin{pmatrix}e_{-m} \\e_{-m+1} &amp; \\\\vdots \\e_{m} \\\\end{pmatrix}$用矩阵形式表示为$Y=XA+E$A的最小二乘解为$\\hat A = (X^TX)^{-1}X^TY$则原信号的滤波值为$\\hat Y = X\\hat A = X(X^TX)^{-1}X^TY$ 参考：SG滤波器原理讲解 小波滤波 原理简介：对于信号$x(t)$，利用小波分解可以表示为尺度空间和细节空间两个分量的值$\\begin{align}x(t) &amp; = \\sum_{k}cA_0(k)\\phi_{j,k}(t)\\ &amp; = \\sum_{k}cA_1(k)\\phi_{j+1,k}(t) + \\sum_{k}cD_1(k)w_{j+1,k}(t)\\end{align}$其中$A_1(k)$和$D_1(k)$分别表示$x(t)$在空间$j+1$的尺度系数和细节系数，为了简便记号，我们可以将第$j$层的系数表示为$A_j = A_{j+1}+D{j+1}$则整个信号可以表示为通常最后1层的尺度系数表示了整个信号的趋势（低频信息），我们可以将该层尺度系数提取出来从而获得信号的基线，或将该层尺度系数置零来去除基线。 参考：小波变换db4进行四层分解及其信号重构—matlab分析及C语言实现 EMD EMD将信号从高频至低频分解为若干阶IMF,整个过程体现了多尺度的滤波过程。借助这一点,我们可以方便地构造一种新型的滤波方式,即根据信号分析的目的,有选择性地把不同的IMF组合起来,以突出信号在某一频率范围内的特征。显然,去掉先分解出来的几阶IMF,把其余的IMF和残余项组合起来,相当于原信号通过了一个低通滤波器。去掉最后分解出来的几阶IMF和残余项,把其余的IMF组合起来,相当于原信号通过了一个高通滤波器。 原理简介： 找到原始信号$X(t)$的极大值和极小值点，然后通过曲线插值方法对这些极值点进行拟合，得到信号的上包络线$X_{max}(t)$和下包络线$X_{min}(t)$。 然后求包络平均值 $m_1(t) = \\frac{X_{max}(t)+X_{min}(t)}{2}$ 对原始信号$X(t)$与平均包络$m_1(t)$进行相减，得到余下信号$d_1(t)$。一般情况下，对于平稳信号而言，它是原始信号$X(t)$的第一个模态函数(IMF)。但对于非平稳信号，信号的并不是在某一个区域内单调递增的，而是会出现拐点。这些能反映原始信号$X(t)$的具体特征的拐点若未被选中，则得到的第一阶模态函数并不准确，也就是通常得到的$d_1(t)$并不满足IMF的两个条件，所以需要继续进行筛选。 对余下信号$d_1(t)$重复上述1~3操作的处理，直到SD(筛分门限值，一般取值0.2-0.3)小于门限值时才停止，这样得到最终合适的第一阶模态分量$c_1(t)$，即第一个IMF。其中SD求法如下： $SD = \\sum_{t=0}^T\\frac{|d_{k-1}(t)-d_k(t)|^2}{d^2_{k-1}(t)}$ 对信号$X(t)$与$c_1(t)$求差，得到第一阶残差量$r_1(t)$，将$r_1(t)$替代原始信号$X(t)$进行步骤1~4的处理，重复 n 次后可获取第 n 阶模态函数$c_n(t)$和最终符合标准的残差量$r_n(t)$。原始信号$X(t)$经EMD分解的表达式为 $X(t) = \\sum{c_n(t)+r_n(t)}$ 参考：经验模式分解EMD算法原理 VMD 在信号处理中，变分模态分解是一种信号分解估计方法。 该方法在获取分解分量的过程中通过迭代搜寻变分模型最优解来确定每个分量的频率中心和带宽，从而能够自适应地实现信号的频域剖分及各分量的有效分离。 原理简介：变分模态分解的整体框架是变分问题，使得每个模态的估计带宽之和最小，其中假设每个“模态”是具有不同中心频率的有限带宽，为解决这一变分问题，采用了交替方向乘子法，不断更新各模态及其中心频率，逐步将各模态解调到相应的基频带，最终各个模态即相应的中心频率被一同提取出来。约束变分表达式为$\\begin{cases}\\underset{&lt;!–swig￼0–&gt;}{min} \\left{||\\partial_t \\left[ \\left(\\delta(t)+\\frac{j}{\\pi t} \\right)*u_k(t) \\right]e^{-jw_kt} ||^2_2\\right}\\\\text{s.t.} \\underset{k}{\\sum}u_k = f\\end{cases}$求解变分约束模型的最优解，可利用二次惩罚函数线$\\alpha$和拉格朗日乘子$\\lambda$：$\\begin{align}L(|u_k|,|w_k|,|\\lambda|):= &amp; \\alpha\\underset{k}{\\sum}||\\partial_t \\left[ \\left(\\delta(t)+\\frac{j}{\\pi t} \\right)*u_k(t) \\right]e^{-jw_kt} ||^2_2 \\ &amp; + ||f(t)-\\underset{k}{\\sum}u_k(t)||^2_2 + \\left\\langle \\lambda(t), f(t)-\\underset{k}{\\sum}u_k(t) \\right\\rangle\\end{align}$利用交替方向乘子算法解决变分问题，交替更新$u_k^{n+1}$,$w_k^{n+1}$,$\\lambda_k^{n+1}$来求解拉格朗日表达式的 “鞍点”。$\\hat{u}_k^{n+1}(w)=\\frac{\\hat{f}(w)-\\underset{i\\ne k}{\\sum}\\hat{u}_i(w)+\\hat{\\lambda}(w)/2}{1+2\\alpha(w-w_k)^2}$$w_k^{n+1}=\\frac{\\int_0^{\\infin}w|\\hat{u}_k(w)|^2dw}{\\int_0^{\\infin}|\\hat{u}_k(w)|^2dw}$ 参考 K. Dragomiretskiy and D. Zosso, “Variational Mode Decomposition,” in IEEE Transactions on Signal Processing, vol. 62, no. 3, pp. 531-544, Feb.1, 2014, doi: 10.1109/TSP.2013.2288675. 分段三次样条插值 每个子区间的多项式函数是三次的，所以名字里有“三次”，整个插值函数曲线由分段三次曲线并接而成，并且在连接点也就是样点上必须要二阶连续可导。 原理简介： 平滑先验滤波平滑先验法原理 (Smoothness Priors Approach, SPA)是芬兰库奥皮奥大学的Karjalainen博士最先提出的一种信号非线性去趋方法, 并有效地应用于人体心电信号。常用的参数辨识算法是最小二乘估计, 而SPA法采用的是一种更为通用的参数估计算法, 称之为正则化最小二乘法 (Regularized Least Squares Solution) 原理简介：对于任意时间序列$z$，可表示为$z=(z_1,z_2,…,z_n)^T=z_{stat}+z_{trend}$其中$z_{stat}$,$z_{trend}$分别代表近似稳态成分和趋势成分。低频成分可以通过下式进行拟合$z_{trend}=H\\Theta + \\varepsilon$其中$H$为观测矩阵，$\\Theta$为回归参数，$\\varepsilon$为观测误差。然后通过正则化最小二乘准则来估计这些回归参数$\\hat{\\Theta}_\\lambda=\\underset{\\Theta}{argmin}\\left{ ||H\\Theta-z||^2+\\lambda^2||D_d(H\\Theta)||^2\\right}$其中$\\lambda$为正则化参数，$D_d$为第d次导数操作的离散逼近。加入一些先验知识偶，上述等式可解为$\\hat{\\Theta}\\lambda=(H_TH+\\lambda^2H_TD^T_dD_dH)^{-1}H^Tz$$\\hat{z{trend}}=H\\hat{\\Theta_\\lambda}$其中，观测矩阵$H$可以包含时间序列$z$的一些已知信息，例如使用一些高斯函数或三角函数。通常，二阶差分矩阵是一个不错的选择$D_2 = \\begin{pmatrix} 1 &amp; -2 &amp; 1 &amp; 0 &amp;\\cdots &amp; 0 \\ 0 &amp; 1 &amp; -2 &amp; 1 &amp; \\cdots &amp; a_2^n \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 0 &amp; \\cdots&amp; \\cdots &amp; 1 &amp; -2 &amp; 1 \\end{pmatrix}$ beads 凸优化 该算法的主要作用在于基线修正、降噪、仪器零漂修正功能。有一个使用的限制条件是被处理信号必须是大多数峰值是正的稀疏信号. 原理简介：与上面类似，不过多介绍了，beads 在 Matlab 上有源码，先看效果在分析$\\hat{x}=\\underset{\\Theta}{argmin}\\left{ F(x)=||H(y-x)||^2_2+\\sum_{i=0}^M\\lambda_iR_i(D_ix)\\right}$ 参考 Chromatogram baseline estimation and denoising using sparsity (BEADS) 实验结果 组合1：CAL 20100 + MIT 基线 各算法用时【0.0038 s】 整系数高通滤波器 0.67 Hz【0.0049 s】 S-G 滤波器【0.0196 s】 小波滤波【0.0202 s】 EMD【4.2227 s】 VMD【0.0373 s】 分段三次样条插值【0.0076 s】 平滑先验【0.4204 s】 beads 组合2：CAL 20110 + MIT 基线 各算法用时【0.0039 s】 整系数高通滤波器 0.67 Hz【0.0048 s】 S-G 滤波器【0.0186 s】 小波滤波【0.0193 s】 EMD【4.3094 s】 VMD【0.0117 s】 分段三次样条插值【0.0075 s】 平滑先验【0.4107 s】 beads 组合3：CAL 20160 + MIT 基线 各算法用时【0.0039 s】 整系数高通滤波器 0.67 Hz【0.0057 s】 S-G 滤波器【0.0094 s】 小波滤波【0.0165 s】 EMD【4.2686 s】 VMD【0.0089 s】 分段三次样条插值【0.0072 s】 平滑先验【0.4083 s】 beads 组合4：CAL 20100 + 单正弦基线 各算法用时【0.0043 s】 整系数高通滤波器 0.67 Hz【0.0056 s】 S-G 滤波器【0.0167 s】 小波滤波【0.0155 s】 EMD【4.2638 s】 VMD【0.0065 s】 分段三次样条插值【0.0071 s】 平滑先验【0.4070 s】 beads 组合5：CAL 20110 + 单正弦基线 各算法用时【0.0043 s】 整系数高通滤波器 0.67 Hz【0.0056 s】 S-G 滤波器【0.0088 s】 小波滤波【0.0179 s】 EMD【4.2580 s】 VMD【0.0070 s】 分段三次样条插值【0.0071 s】 平滑先验【0.4181 s】 beads 组合6：CAL 20160 + 单正弦基线 各算法用时【0.0041 s】 整系数高通滤波器 0.67 Hz【0.0049 s】 S-G 滤波器【0.0076 s】 小波滤波【0.0159 s】 EMD【4.3430 s】 VMD【0.0076 s】 分段三次样条插值【0.0069 s】 平滑先验【0.4068 s】 beads 组合7：CAL 20100 + 多正弦基线 各算法用时【0.0043 s】 整系数高通滤波器 0.67 Hz【0.0056 s】 S-G 滤波器【0.0079 s】 小波滤波【0.0182 s】 EMD【4.2775 s】 VMD【0.0067 s】 分段三次样条插值【0.0079 s】 平滑先验【0.4143 s】 beads 组合8：CAL 20110 + 多正弦基线 各算法用时【0.0042 s】 整系数高通滤波器 0.67 Hz【0.0055 s】 S-G 滤波器【0.0073 s】 小波滤波【0.0183 s】 EMD【4.3131 s】 VMD【0.0070 s】 分段三次样条插值【0.0081 s】 平滑先验【0.4117 s】 beads 组合9：CAL 20160 + 多正弦基线 各算法用时【0.0039 s】 整系数高通滤波器 0.67 Hz【0.0061 s】 S-G 滤波器【0.0077 s】 小波滤波【0.0207 s】 EMD【4.2227 s】 VMD【0.0068 s】 分段三次样条插值【0.0072 s】 平滑先验【0.4216 s】 beads 组合10：门信号 各算法用时【0.0073 s】 整系数高通滤波器 0.67 Hz【0.0056 s】 S-G 滤波器【0.0071 s】 小波滤波【0.0108 s】 EMD【3.9332 s】 VMD【0.0065 s】 分段三次样条插值【0.0071 s】 平滑先验【0.4002 s】 beads 实验分析综合各组实验结果，总结下表 方法 滤波效果 算法用时 (20 s信号) 优点 缺点 0.67 Hz整系数高通滤波 基准 ~0.004 s 快，易实现 可能会影响ST段，或基线滤不干净 S-G 滤波 能去除基线但会使波形失真 ~0.005 s 快，基线去除效果好 波形失真， 矩形信号严重失真 小波滤波 - - - - EMD 滤波 接近但略差于基准 ~0.01 s 快，波形不失真 基线滤不干净 VMD 滤波 基线去除效果好但会使波形失真 ~ 4 s 基线去除效果好 慢，波形失真 分段三次样条插值滤波 效果取决于噪声和拟合效果 ~ 0.007 s 快 滤波效果不确定，且偶尔会使头尾信号突变 平滑先验滤波 基线去除效果好但会使波形失真 ~ 0.007 s 快，基线去除效果好 波形严重失真 beads 滤波 基线去除效果好，波形基本不失真 ~ 0.4 s 基线去除效果好，波形基本不失真 稍慢，只能适用于各个波段均在基线之上的情况。当波段低于基线时，使用 beads 滤波会使波形失真。 实验难点部分滤波方法原理实现起来不方便，而且对部分参数理解不深刻，无法达到论文中的最优解 实验结论每个滤波器都有各自的优缺点，暂时还无法找到一个滤波器能够满足既可以避免ST失真又能修正基线漂移，但是给后续实验提供了一些思路。为了解决ST失真和基线漂移的问题，在基于本次实验的滤波器基础上，可以进行尝试的方向有： 0.67 Hz整系数高通滤波 + 拟合 来去除未滤干净的基线 自适应的 EMD 滤波 优化 beads 滤波器","link":"/2022/05/24/%E5%9F%BA%E7%BA%BF%E4%BF%AE%E6%AD%A3/"}],"tags":[{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"滤波","slug":"滤波","link":"/tags/%E6%BB%A4%E6%B3%A2/"}],"categories":[{"name":"C","slug":"C","link":"/categories/C/"}]}