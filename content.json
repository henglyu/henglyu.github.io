{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/05/07/hello-world/"},{"title":"基于Github+Hexo的博客搭建","text":"准备工作使用Github+Hexo搭建博客，前期需要四个工具 环境 描述 GitHub 国内一款面向开发者的云端开发平台，提供代码托管，运行空间，质量控制，项目管理等功能 Git 一款免费、开源的分布式版本控制系统 Node.js 建立在Chrome上的JavaScript运行引擎 Hexo Hexo快速、简洁且高效的博客框架 1.1、安装与配置环境安装必要的配置环境，如果已经安装过，可以跳过。 Github Github 官方网站：https://github.com/ 注册一个 Github 账号。 新建一个 Repository，格式为【你的Github账户名.github.io】 Git 参考：https://blog.csdn.net/qq_41782425/article/details/85183250 安装Git Git 下载地址 ：https://git-scm.com/downloads 安装系统对应版本 Git，全部默认配置即可。 配置Git 打开 Git Bash 命令行（打开 Git Bash 快捷方式或右键选择 Git Bash Here 都可）。 配置用户名、邮箱（替换双引号内为对应名称即可）。 12git config --global user.name &quot;yourusername&quot;git config --global user.email &quot;youremail@example.com&quot; 创建 SSH Key 12cd ~/.sshssh-keygen -t rsa -C &quot;youremail@example.com&quot; 创建完成后，在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人. 登录github注册或登录账号，打开“settings”的“SSH Keys”页面，然后，点“New SSH Key”，填上任意 Title，在 Key 文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的 Key。 安装Node.js 下载地址：https://nodejs.org/en/ 下载LTS的，一直点Next，除了改安装目录外，其他按照默认的就可以。打开 Node.js command prompt 命令行窗口，输入 node -v 和 **npm -v **如果可以正常出现版本号，证明安装成功了！(要是这里出现了问题那就从头开始吧…) 安装 Hexo在 Node.js command prompt 命令行窗口输入下面命令来安装 Hexo： 123npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-clihexo -v 能够正常出现版本信息就成功了！(如果失败，就重新安装吧) 开始搭建创建博客 在任意地方创建文件夹，用于储存博客内容。如 D:\\blog。 使用hexo来初始化blog。 123cd blog/hexo inithexo s 然后会生成一个地址: http://localhost:4000 在浏览器中打开可以看到已经初始化的博客 然后就可以在 blog/source/_posts 文件夹中编辑博客了。 把 hexo 搭建的博客部署到 Github 上 回到命令行窗口，在blog目录下安装一个git部署插件： 1cnpm install --save hexo-deployer-git 打开blog文件夹，编辑 **”_config.yml” **文件(可以用文本编辑器Notepad++)拉到文件夹最底部，修改如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 'git' repo: 这里的地址就是你刚刚创建的仓库的地址，即：https://github.com/你的Github名/你的Github名.github.io.git 这种格式 branch: master 最后一步，部署到远端： 1hexo s 这里可能会跳出来窗口让你输入你的GitHub名和密码。回到你的GitHub仓库，刚刚创建的空仓库会多了很多东西。以后访问博客就可以在浏览器输入”你的Github账户名.github.io”进行访问了！！！例如：henglyu.github.io 选择一个主题 主题官网：https://hexo.io/themes/ 这里我以 ICARUS 为例， 官网中也给出了教程：Icarus快速上手 从GitHub的仓库中下载源码的压缩包并解压到你Hexo站点的主题目录中。 或者，你可以使用Git来克隆Icarus的代码仓库到themes目录下： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 接下来，在你的站点的_config.yml文件中的开启Icarus： 1hexo config theme icarus 最后，使用如下命令来启动Hexo本地测试服务器并开始创作。 1hexo server 配置主题各个参数 参考：Icarus用户指南 - 主题配置 打开 _config.icarus.yml 文件，进行主题配置 ，参考上面官网教程，这里不再赘述。 NOTE由于本人不是前端工程师，搭建博客的初衷也是想拥有自己的知识库，以便知识的沉淀。因此在此处不做过多的研究，搭建出能用的框架即可。","link":"/2022/05/07/%E5%9F%BA%E4%BA%8EGithub+Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"C语言项目编码规范(个人用)","text":"项目创建项目目录结构创建一个项目时，按照以下目录结构创建： 12345678910111213141516171819202122232425262728293031323334project [项目]|- data [存放数据的文件夹]| |- data set 1 [数据集1]| |- data set 2 [数据集2]| |- ...| |- dataDescription.md [数据集描述]|- doc [项目描述文件夹]| |- matlab code [项目预演 matlab 代码]| |- project algorithms description [项目算法描述文档]| |- project review record [项目评审记录]| |- other related files [其他项目相关文档]|- src [项目源文件]| |- main functions.c/.h [对外接口头文件和源文件]| |- module 1 functions.c/.h [模块 1 头文件和源文件]| |- module 2 functions.c/.h [模块 2 头文件和源文件]| |- ...| |- CMakeList.txt [Cmake 配置]|- test [项目测试文件]| |- integration test [集成测试]| | |- it_project.cpp | | |- CMakeList.txt | |- system test [系统测试]| | |- st_project.cpp | | |- CMakeList.txt | |- unit test [单元测试]| | |- ut_module1.cpp [模块 1 测试]| | |- ut_module2.cpp [模块 2 测试]| | |- ...| | |- CMakeList.txt|- tools [项目使用的相关工具]|- CMakeList.txt [项目 Cmake 配置]|- config.h.in [项目配置文件]|- example.cpp [项目例子程序]|- descriptions of project using [项目操作说明文档] 项目通用配置项src/CMakeList.txt >folded1234567891011121314151617181920212223242526272829# 设置应用程序名称 set(libName ${PROJECT_NAME}) # 对外公开头文件 file(GLOB lib_hxx ${CMAKE_CURRENT_SOURCE_DIR}/${libName}.h ) # 将工程目录下的子目录中所有源文件名称保存到变量中 file(GLOB_RECURSE lib_src ${CMAKE_CURRENT_SOURCE_DIR}/*.h ${CMAKE_CURRENT_SOURCE_DIR}/*.hpp ${CMAKE_CURRENT_SOURCE_DIR}/*.c ${CMAKE_CURRENT_SOURCE_DIR}/*.cc ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp ) # 将CMake设置文件添加到包含文件的搜索路径中 include_directories(${incPath}) link_directories(${linkPath}) # 编译库文件 add_library(${libName} STATIC ${lib_src}) # 安装库文件到指定路径 install(TARGETS ${libName} DESTINATION ${out_dir_lib}) # 安装库引用文件到指定路径 install(FILES ${lib_hxx} DESTINATION ${out_dir_include}) test/CMakeList.txt >folded1234567if(NOT DEFINED ENV{GTEST_HOME}) set(ENV{GTEST_HOME} &quot;C:\\\\gtest&quot;) endif() add_subdirectory(unit_test) add_subdirectory(integration_test) add_subdirectory(system_test) test/integreation_test/CMakeList.txt >folded1234567891011121314151617181920212223242526272829303132333435363738# 设置单元测试程序名称 set(appName ${PROJECT_NAME}_it) link_directories(${linkPath}) # 将第三方库（GTest）头文件添加到包含文件的搜索路径中，相当于 -Iinclude_directories( ${incPath} $ENV{GTEST_HOME}/include $ENV{GTEST_HOME}/include/gtest ${PROJECT_SOURCE_DIR}/src ${PROJECT_SOURCE_DIR}/libs/include ) # 设置第三方库（GTest）库文件链接的目录，相当于 -Llink_directories( ${linkPath} $ENV{GTEST_HOME}/lib ) # 链接第三方库（GTest），用于链接静态库，定义在 add_executable 之前 link_libraries(gtest) # 将工程目录下的子目录中所有源文件名称保存到变量中 file(GLOB_RECURSE lib_src ${CMAKE_CURRENT_SOURCE_DIR}/*.h ${CMAKE_CURRENT_SOURCE_DIR}/*.hpp ${CMAKE_CURRENT_SOURCE_DIR}/*.c ${CMAKE_CURRENT_SOURCE_DIR}/*.cc ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp ) # 编译可执行文件 add_executable(${appName} ${lib_src} ) # 标准库和自定义库指定，用于链接动态库，定义在 add_executable 之后，相当于 -ltarget_link_libraries(${appName} ${PROJECT_NAME} -Wl,--whole-archive ${dependencyLibrarys} -Wl,--no-whole-archive pthread gtest gtest_main ) CMakeList.txt >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# 设置cmake最低版本 cmake_minimum_required(VERSION 3.15) STRING(REGEX REPLACE &quot;.*/(.*)&quot; &quot;\\\\1&quot; PROJECT_NAME ${CMAKE_CURRENT_SOURCE_DIR}) # 设置工程名称 project(${PROJECT_NAME}) set(CMAKE_CXX_STANDARD 11) # 设置库版本号 (将 0.0.0.0 更改为对应版本号，每次代码提交都要变更)set(LIB_VERSION 0.0.0.0) # 数据保存开关，用于保存依赖子库的数据 #set(SAVE_DATA_MODE ON) # 设置安装路径 if(NOT DEFINED ${out_dir}) set(out_dir &quot;${PROJECT_SOURCE_DIR}/..&quot;) endif() set(CMAKE_INSTALL_PREFIX &quot;${out_dir}&quot;) # 设置库文件安装路径 set(out_dir_lib &quot;${out_dir}/lib&quot;) # 设置库文件安装路径 set(out_bin_lib &quot;${out_dir}/bin/${PROJECT_NAME}&quot;) # 设置库引用文件安装路径 set(out_dir_include &quot;${out_dir}/include&quot;) # ON(单片机模式)，OFF(文件系统模式) set(SINGLE_CHIP_MODE OFF) #设置依赖库 （自行设置）set(dependencyLibrarys libyyjson libanal_log libyyini libanal_serialize) # 编译时间 string(TIMESTAMP BUILD_TIME &quot;%Y-%m-%d %H:%M:%S&quot;) set(LIB_BUILD_TIME ${BUILD_TIME}) set(libName ${PROJECT_NAME}) # 配置一个头文件，通过它向源代码中传递一些CMake设置 configure_file( &quot;${PROJECT_SOURCE_DIR}/config.h.in&quot; &quot;${PROJECT_BINARY_DIR}/config.h&quot; ) # 输出库编译信息 message(STATUS &quot;${PROJECT_NAME} version: ${LIB_VERSION}&quot;) message(STATUS &quot;${PROJECT_NAME} build time: ${BUILD_TIME}&quot;) # 数据保存开关打开则增加宏定义 SAVE_DATA_MODEif (${SAVE_DATA_MODE} AND ${SAVE_DATA_MODE} STREQUAL &quot;ON&quot;) add_compile_definitions(SAVE_DATA_MODE=1) add_definitions(-DSAVE_DATA_MODE=1) endif () # 设置头文件路径 set(incPath ${PROJECT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/src ${out_dir_include}) # 设置链接库路径 set(linkPath ${out_dir_lib}) add_definitions(-DCUR_LIB_PATH=&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;) # 配置所依赖的静态库 foreach (l ${dependencyLibrarys}) add_library(${l} STATIC IMPORTED) set_property(TARGET ${l} PROPERTY IMPORTED_LOCATION ${linkPath}/${l}.a) endforeach () # 依次编译内部使用库 add_subdirectory(src) IF (CMAKE_SYSTEM_NAME MATCHES &quot;Windows&quot;) add_subdirectory(test) ENDIF () # 设置头文件搜索路径 include_directories( ${PROJECT_SOURCE_DIR}/src ${incPath}) # 设置库搜索路径 link_directories(${linkPath}) # 编译可执行文件 add_executable(${PROJECT_NAME}_example example.cpp) target_link_libraries(${PROJECT_NAME}_example ${PROJECT_NAME} -Wl,--whole-archive ${dependencyLibrarys} -Wl,--no-whole-archive ) # 安装例子程序到指定路径 install(TARGETS ${PROJECT_NAME}_example DESTINATION ${out_bin_lib}) # 安装库引用文件到指定路径 install(FILES example.cpp DESTINATION ${out_bin_lib}) config.h.in >folded12345678#ifndef CONFIG_H #define CONFIG_H #define LIB_VERSION &quot;@LIB_VERSION@&quot; #define LIB_NAME &quot;@libName@&quot; #define LIB_BUILD_TIME &quot;@LIB_BUILD_TIME@&quot; #endif // CONFIG_H 项目代码编写流程准备阶段 根据 项目目录结构 创建对应文件夹与文件，可以编写通用模板，以便可以直接复制从而创建新项目 在 doc 文件夹放置算法的设计思路文件与 MATLAB 预演代码（假设已经在 MATLAB 进行过实验） 确定对外接口头文件 ProjectName.h 和对应源文件 ProjectName.c（源文件此时为一系列空函数） 预先准备好测试数据与预期的结果数据，放入 data 文件夹（一般情况下应与 MATLAB 预演版本数据保持一致） 修改 example.cpp 文件，调用 ProjectName.c 的空文件，完成整个项目的框架 修改 CMakeLists.txt 文件（修改版本号，如果调用了外部库则需要添加依赖库） 调试 example.cpp 代码 ，确保在框架的正常运行 编码阶段 在 src 文件夹下编写功能代码 在 test/unit_test 文件夹下编写单元测试代码 调试 src 和 test/unit 文件夹下的代码直到测试通过 在 ProjectName.c 中调用 src 各个模块的子函数 调试 example.cpp 代码，直至输出与预期相符 编写 Readme.md 例子程序说明文档，介绍本项目的功能、参数、注意事项、函数调用流程等 测试阶段 在 test/integration_test 中编写集成测试，主要测试接口输入参数的异常处理，函数调用顺序的异常处理 在 test/system_test 中编写系统测试，主要测试异常数据导致的错误 C语言编码规范主要参考 PEP7，并做了适当调整 排版 使用 4 个空格的缩进，完全没有制表符。 任何行都不应超过 79 个字符。 任何行都不应该以空格结尾 函数定义风格：‘{’ 不需独占一行，‘}’ 需独占一行，同时与引用代码块的语句左对齐，局部变量声明后空行。123456789static intextra_ivars(PyTypeObject *type, PyTypeObject *base){ int t_size = PyType_BASICSIZE(type); int b_size = PyType_BASICSIZE(base); assert(t_size &gt;= b_size); /* type smaller than base! */ ... return 1;} 代码结构：关键字（如if、for）和后面的左括号之间有一个空格；括号内没有空格；即使 C 允许省略，任何地方都需要大括号，但不要将它们添加到您没有修改的代码中。所有新的 C 代码都需要大括号。大括号的格式应如下所示：123456if (mro != NULL) { ...}else { ...} return 语句不应该有多余的_括号_12return albatross; /* correct */return(albatross); /* incorrect */ 函数和宏调用风格：foo(a, b, c) - 左括号前无空格，括号内无空格，逗号前无空格，每个逗号后一个空格。 始终在赋值、布尔和比较运算符周围放置空格。在使用大量运算符的表达式中，在最外层（最低优先级）运算符周围添加空格。 打断长行：如果可以的话，在最外层参数列表中的逗号后打断。始终适当地缩进续行，例如：123PyErr_Format(PyExc_TypeError, &quot;cannot create '%.100s' instances&quot;, type-&gt;tp_name); 当您在二元运算符处中断一个长表达式时，该运算符位于上一行的末尾，并且括号应按所示格式化。例如：123456if (type-&gt;tp_dictoffset != 0 &amp;&amp; base-&gt;tp_dictoffset == 0 &amp;&amp; type-&gt;tp_dictoffset == b_size &amp;&amp; (size_t)t_size == b_size + sizeof(PyObject *)){ return 0; /* &quot;Forgive&quot; adding a __dict__ only */} 在函数、结构定义和函数内部的主要部分周围放置空白行。 注释位于他们描述的代码之前。 所有函数和全局变量都应声明为静态，除非它们是已发布接口的一部分 对于外部函数和变量，我们总是在“Include”目录下合适的头文件中声明，其中使用了 PyAPI_FUNC() 宏和 PyAPI_DATA() 宏，如：12PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);PyAPI_DATA(PyTypeObject) PySuper_Type; 命名单词命名 不允许使用单个字符（如 i j k）命名，作为局部循环变量除外 命名单词为全英文，不允许使用中文拼音 函数/方法名：一般采用动宾结构命名。如果是类中的方法名，可以直接使用动词结构 避免使用无意义或含义不清的动词为函数命名。如 process、handle 外部可见的标识符应加上模块名，防止编译、链接时产生冲突 用正确的反义词组命名具有互斥意义的变量或相反动作的函数 word 1 word 2 word 1 word 2 word 1 word 2 add remove begin end create destroy insert previous first last get release next decrement put get add delete lock unlock open close min max old new start stop increment decrement cut paste up down 命名风格 包/文件夹：采用小驼峰命名规则，比如 ecgBinaryClassification 文件名：下划线方式，比如 ecg_binary_classification 类/结构体/自定义类型名：大驼峰法，比如 EcgBinaryClassification 函数/方法名：采用小驼峰或下划线，这里建议采用小驼峰方式 局部变量名：采用小驼峰或下划线，这里建议采用小驼峰方式 静态变量名：采用在局部变量规则前加 s_ 的形式 全局变量名：采用在局部变量规则前加 g_ 的形式 内部符号：采用在符号前加 _ 的形式 私有符号：采用在符号前加 __ 的形式 常量：全部大写，单词与单词之间采用下划线连接 注释源程序有效注释量必须在20％以上 文件注释123456789101112131415161718192021222324252627282930/** * @file 文件名* @brief 实例功能简述 * @details 实例功能详述 * @author 作者名* @date 2022-5-13 14:47:11* @version 版本号* @copyright Copyright * @attention * &lt;ul&gt; * &lt;li&gt;注意1&lt;/li&gt; * &lt;li&gt;注意2&lt;/li&gt; * &lt;/ul&gt; * @par 修改日志 * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;日期&lt;/th&gt; * &lt;th&gt;版本&lt;/th&gt; * &lt;th&gt;作者&lt;/th&gt; * &lt;th&gt;修改内容&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本1&lt;/td&gt; * &lt;td&gt;创建者名称&lt;/td&gt; * &lt;td&gt;创建初始版本&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本2&lt;/td&gt; * &lt;td&gt;修改者名称&lt;/td&gt; * &lt;td&gt;修改内容&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; */ 函数注释 函数，原则上都需要加注释，尤其是接口函数和逻辑比较复杂的函数 函数的返回值注释要清楚、明了123456789101112131415161718/** * @name 函数名* @brief 函数功能简介 * @details 函数详细描述* * @param[in] 输入变量名 输入变量介绍* @param[out] 输出变量名 输出变量介绍* @return 返回值* * @author 作者* @date 时间* * @par 示例: * @code * 函数使用实例 * @endcode * @see 类、结构体、枚举等（超链接） */ 变量注释 变量：要求静态变量和全局变量必须加注释 命名中若使用特殊约定或缩写，必须有注释说明 其他注释 语句：有技巧性的代码语句，必须添加注释 TODO：尽量不使用 “待完善” “待明确”等模糊词，而使用相对明确的方式，如# TODO(author) 添加低通滤波功能. 函数 每个函数完成一个功能 函数的入参和出参不允许直接传递结构体对象，需改为指针 行数限制 200 行，如果某个函数有效代码超过 200 行，考虑分拆。 语句嵌套：主要是 if...else ,, while ， for 等，要求嵌套不超过 3 层， switch...case 不超过五层。 明确函数功能，精确（而不是近似）地实现函数设计 对所调用函数的错误返回码要仔细、全面地处理 编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V 操作）等手段对其加以保护 检查函数所有参数输入的有效性 检查函数所有非参数输入的有效性，如数据文件、公共变量等 防止把没有关联的语句放到一个函数中。在编程时，经常遇到在不同函数中使用相同的代码，需要把这些代码提出来，并构成一个新函数。 减少函数本身或函数间的递归调用 不能随意改变与其它模块的接口 数入参为指针或者有其他有限制的值时必须加入入参检测 语句循环 循环体内工作量最小化 避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中 在多重循环中，应将最忙的循环放在最内层 要防止差1 错误。此类错误一般是由于把 &lt;=** 误写成 **&lt;** 或 **&gt;= 误写成 &gt; 等造成的，由此引起的后果，很多情况下是很严重的 for 循环中不要使用 return 来退出双重循环，可以使用标志位判断来退出双重循环 临界资源操作临界资源包括内存、文件、句柄等 过程/函数中分配的内存，在过程/函数退出之前要释放 过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭 申请了临界资源后只有一个出口 return 来退出过程/函数，以防止忘记关闭临界资源 防止内存/数组操作越界 其他 用括号明确表达式的操作顺序，避免使用默认优先级 判断条件的执行语句必须用花括号括起来 不允许直接使用数字，需用宏定义或变量替换 关系较为紧密的代码应尽可能相邻 要使用难懂的技巧性很高的语句，除非很有必要时。且必须加注释 尽量减少没有必要的数据类型默认转换与强制转换 初始化有关变量及运行环境，防止未经初始化的变量被引用 判断性语句，把常量放在表达式的左边 if 语句尽量加上 else 分支，对没有 else 分支的语句要小心对待；switch 语句必须有 default 分支 使用变量时要注意其边界值的情况。如 C 语言中字符型变量，有效值范围为 -128 到 127 求余和除法要做除数的0值判断 用 free() 函数时需要对入参判断其是否为空指针 自定义类型 结构的功能要单一 不要设计面面俱到、非常灵活的数据结构 仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象 避免使用 BOOL 类型 变量 申请的变量必须初始化 严禁使用未经初始化的变量作为右值 使用静态变量和全局变量时，仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系 代码测试 单元测试要求至少达到语句覆盖。 单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。 清理、整理或优化后的代码要经过审查及测试。 代码版本升级要经过严格测试。 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题 仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。 尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。 仔细测试代码处理数据、变量的边界情况 不应通过“试”来解决问题，应寻找问题的根本原因。 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题 其他 去除编译中的所有警告","link":"/2022/05/13/C%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83-%E4%B8%AA%E4%BA%BA%E7%94%A8/"},{"title":"C语言-一种面向对象的编程模板","text":"使用该模板需要按照 编程规范目录形式配置项目。 demo_lib123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280/** * @file demo_lib.c * @brief 找最大值为例的编程模板* @details 找最大值为例的编程模板* @author * @date * @version * @copyright * @attention * &lt;ul&gt; * &lt;li&gt;注意1&lt;/li&gt; * &lt;li&gt;注意2&lt;/li&gt; * &lt;/ul&gt; * @par 修改日志 * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;日期&lt;/th&gt; * &lt;th&gt;版本&lt;/th&gt; * &lt;th&gt;作者&lt;/th&gt; * &lt;th&gt;修改内容&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本1&lt;/td&gt; * &lt;td&gt;创建者名称&lt;/td&gt; * &lt;td&gt;创建初始版本&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;日期&lt;/td&gt; * &lt;td&gt;版本2&lt;/td&gt; * &lt;td&gt;修改者名称&lt;/td&gt; * &lt;td&gt;修改内容&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; */ #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &quot;config.h&quot; #include &quot;demo_lib.h&quot; #ifdef LOG_TAG #undef LOG_TAG #endif #define LOG_TAG &quot;demo lib&quot; /** * @name demoLibVersion * @brief 获取库的版本号 * @details 获取库的版本号 * * @return 库的版本号 * * @author * @date * */ const char *demoLibVersion(void) { return LIB_NAME &quot; version &quot; LIB_VERSION &quot; &quot; LIB_BUILD_TIME; } /** * @name newDemoLib * @brief 库初始化 * @details 库初始化 * * @param[in] conf 配置结构体 * @return * @retval 0 成功 * @retval !0 失败 * * @author * @date * */ DemoLib *newDemoLib(const DemoLibConf *conf) { DemoLib *_this = NULL; // 入参有效性检查 if ((NULL == conf) || (NULL == conf-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return _this; } // 记录调用操作 LOGI(&quot;%s&quot;, conf-&gt;name); /************************* 申请资源 **************************/// 计算空间大小 size_t len = sizeof(DemoLib) + strnlen(conf-&gt;name, MAX_STR_LEN) + 1; if ((conf-&gt;dataPath) &amp;&amp; (0 &lt; strnlen(conf-&gt;dataPath, MAX_STR_LEN))) { len += strnlen(conf-&gt;dataPath, MAX_STR_LEN) + 1; } // 申请空间 void *p = malloc(len); if (p) { memset(p, 0, len); // 初始化 _this = (DemoLib *) p; char *name = (char *) p + sizeof(DemoLib); strncpy(name, conf-&gt;name, strnlen(conf-&gt;name, MAX_STR_LEN)); _this-&gt;name = name; _this-&gt;fs = conf-&gt;fs; /************************* 如果配置了数据路径则开启记录 **************************/ if (conf-&gt;dataPath) { if (0 &lt; strnlen(conf-&gt;dataPath, MAX_STR_LEN)) { char *dataPath = (char *) _this-&gt;name + strnlen(_this-&gt;name, MAX_STR_LEN) + 1; strncpy(dataPath, conf-&gt;dataPath, strnlen(conf-&gt;dataPath, MAX_STR_LEN)); _this-&gt;dataPath = dataPath; } else { // 路径为空字符串时，使用当前运行路径 _this-&gt;dataPath = &quot;.&quot;; } // 记录配置信息 char fileName[MAX_STR_LEN] = {0}; snprintf(fileName, sizeof(fileName), &quot;%s/demo_lib.conf&quot;, conf-&gt;dataPath); //serializeWriteData(fileName, conf, AS_DemoLibConf); // 打开实时记录输入文件 memset(fileName, 0, sizeof(fileName)); snprintf(fileName, sizeof(fileName), &quot;%s/realtimeDemoLibScan_in.csv&quot;, conf-&gt;dataPath); _this-&gt;fdIn = fopen(fileName, &quot;w&quot;); // 打开实时记录输出文件 memset(fileName, 0, sizeof(fileName)); snprintf(fileName, sizeof(fileName), &quot;%s/realtimeDemoLibScan_out.csv&quot;, conf-&gt;dataPath); _this-&gt;fdOut = fopen(fileName, &quot;w&quot;); } else { _this-&gt;dataPath = NULL; } } return _this; } /** * @name delDemoLib * @brief 库资源释放 * @details 库资源释放 * * @return * @retval 0 成功 * @retval !0 失败 * * @author zq537 * @date 2021-01-27 15:08 * */ int delDemoLib(DemoLib **_thisP) { // 入参有效性检查 if ((NULL == _thisP) || (NULL == *_thisP) || (NULL == ((DemoLib *)*_thisP)-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return -1; } DemoLib *_this = *_thisP; // 记录调用操作 //LOGI(&quot;%s&quot;, _this-&gt;name); /************************* 释放资源 **************************/ if (_this-&gt;fdIn) { fclose(_this-&gt;fdIn); } if (_this-&gt;fdOut) { fclose(_this-&gt;fdOut); } // 释放空间 free(_this); *_thisP = NULL; return 0; } static int _initDemoLib(DemoLib *_this) { memset(_this-&gt;demoLibResult, 0, sizeof(_this-&gt;demoLibResult)); _this-&gt;lastResult = 0; return 0; } /** * @name initDemoLib * @brief 库初始化 * @details 库初始化 * * @return * @retval 0 成功 * @retval !0 失败 * * @author zq537 * @date 2021-01-27 15:08 * */ int initDemoLib(DemoLib *_this) { // 入参有效性检查 if ((NULL == _this) || (NULL == _this-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return -1; } // 记录调用操作 //LOGI(&quot;%s&quot;, _this-&gt;name); return _initDemoLib(_this); } static int _realtimeDemoLibScan(DemoLib *_this, const int data) { if (_this-&gt;lastResult &lt; data) { _this-&gt;lastResult = data; } return _this-&gt;lastResult; } /** * @name demoLibScan * @brief 找数据中的最大值 * @details * * @param[in] data 数据数组 * @param[in] dataNum 数据数组长度 * @return 最大值 * * @author zq537 * @date 2021/1/27 14:55 * * @par 示例: * @code * 函数使用实例 * @endcode * @see 类、结构体、枚举等（超链接） */ int demoLibScan(DemoLib *_this, const int *data, const int dataNum) { // 入参有效性检查 if ((NULL == _this) || (NULL == _this-&gt;name) || (NULL == data) || (0 &gt;= dataNum)) { LOGE(&quot;Input parameter exception.&quot;); return -1; } //记录调用操作 //LOGI(&quot;%s&quot;, _this-&gt;name); /************************* 记录输入数据 **************************/ if (_this-&gt;dataPath) { char fileName[256] = {0}; snprintf(fileName, sizeof(fileName), &quot;%s/demoLibScan_in.csv&quot;, _this-&gt;dataPath); //serializeWriteDataArray(fileName, data, dataNum, AS_Int); } /************************* 库的实际功能代码 **************************/// todo:初始化 _this 内的所有缓存 _initDemoLib(_this); int maxData = 0; for (int i = 0; i &lt; dataNum; ++i) { maxData = _realtimeDemoLibScan(_this, data[i]); } /************************* 记录输出数据 **************************/ if (_this-&gt;dataPath) { char fileName[256] = {0}; snprintf(fileName, sizeof(fileName), &quot;%s/demoLibScan_out.csv&quot;, _this-&gt;dataPath); // serializeWriteData(fileName, &amp;maxData, AS_Int); FILE *fd = fopen(fileName, &quot;w&quot;); fprintf(fd,&quot;%d&quot;,maxData); fclose(fd); } return maxData; } int realtimeDemoLibScan(DemoLib *_this, const int data) { // 入参有效性检查 if ((NULL == _this) || (NULL == _this-&gt;name)) { //LOGE(&quot;Input parameter exception.&quot;); return -1; } //记录调用操作，此行非必须行。如果操作频繁导致日志太多则注释掉改行 // LOGI(&quot;%s&quot;, _this-&gt;name); /************************* 记录输入数据 **************************/ if (_this-&gt;fdIn) { fprintf(_this-&gt;fdIn, &quot;%d\\n&quot;, data); fflush(_this-&gt;fdIn); } /************************* 库的实际功能代码 **************************/ int maxData = _realtimeDemoLibScan(_this, data); /************************* 记录输出数据 **************************/ if (_this-&gt;fdOut) { fprintf(_this-&gt;fdOut, &quot;%d\\n&quot;, maxData); fflush(_this-&gt;fdOut); } return maxData; }","link":"/2022/05/13/C%E8%AF%AD%E8%A8%80-%E4%B8%80%E7%A7%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"C","slug":"C","link":"/tags/C/"}],"categories":[{"name":"C","slug":"C","link":"/categories/C/"}]}